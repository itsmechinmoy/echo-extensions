name: Spotify Token Extractor
on:
  workflow_dispatch: # Manual trigger
  schedule:
    - cron: '0 */6 * * *' # Run every 6 hours
jobs:
  extract-tokens:
    runs-on: ubuntu-latest
   
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
     
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
       
    - name: Install dependencies
      run: |
        npm install puppeteer
       
    - name: Create extraction script
      run: |
        cat > extract_tokens.js << 'EOF'
        const puppeteer = require('puppeteer');
        const fs = require('fs');
        (async () => {
          const browser = await puppeteer.launch({
            headless: 'new',
            args: [
              '--no-sandbox',
              '--disable-setuid-sandbox',
              '--disable-dev-shm-usage',
              '--disable-accelerated-2d-canvas',
              '--no-first-run',
              '--no-zygote',
              '--disable-gpu'
            ]
          });
          const page = await browser.newPage();
         
          // Set user agent to avoid detection
          await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
         
          let tokens = null;
          let extractionComplete = false;
          // Inject the token extraction logic
          await page.evaluateOnNewDocument(() => {
            const patches = [
              {
                find: /=\[\w{2},\w{2},\w{2}\];const/,
                replacement: [
                  {
                    match: /(=\[\w{2},\w{2},\w{2}\];const \w{2}=(\w{2});)/,
                    replace: (full, _, ve) => {
                      const result = `${full};window.TOKENS=${ve};console.log('TOKENS_FOUND:', JSON.stringify(${ve}));`;
                      window.postMessage({ type: 'TOKENS_EXTRACTED', tokens: ve }, '*');
                      return result;
                    }
                  }
                ]
              }
            ];
            // Token extraction logic (modified from original script)
            Object.defineProperty(Function.prototype, "m", {
              set(v) {
                const source = this.toString();
                if (
                  source.includes("exports") &&
                  (source.includes("false") || source.includes("!1")) &&
                  !(Array.isArray(v) && v?.some(m => m.toString().includes("CHROME_WEBSTORE_EXTENSION_ID")))
                ) {
                  Object.defineProperty(this, "m", {
                    value: v,
                    configurable: true,
                    enumerable: true,
                    writable: true
                  });
                  patchFactories(v);
                  delete Function.prototype.m;
                  this.m = v;
                  console.log("WebpackGrabber: Found webpack_require!");
                } else {
                  Object.defineProperty(this, "m", {
                    value: v,
                    configurable: true,
                    writable: true,
                    enumerable: true
                  });
                }
              },
              configurable: true,
            });
            let webpackChunk = [];
            Object.defineProperty(window, "webpackChunk_N_E", {
              configurable: true,
              get: () => webpackChunk,
              set: (v) => {
                if (v?.push && !v.push.$$vencordOriginal) {
                  console.log('Patching webpackChunk_N_E.push');
                  patchPush(v);
                  delete window.webpackChunk_N_E;
                  window.webpackChunk_N_E = v;
                }
                webpackChunk = v;
              }
            });
            function patchPush(webpackGlobal) {
              function handlePush(chunk) {
                try {
                  patchFactories(chunk[1]);
                } catch (err) {
                  console.error("Error in handlePush", err);
                }
                return handlePush.$$vencordOriginal.call(webpackGlobal, chunk);
              }
              handlePush.$$vencordOriginal = webpackGlobal.push;
              handlePush.toString = handlePush.$$vencordOriginal.toString.bind(handlePush.$$vencordOriginal);
              handlePush.bind = (...args) => handlePush.$$vencordOriginal.bind(...args);
              Object.defineProperty(webpackGlobal, "push", {
                configurable: true,
                get: () => handlePush,
                set(v) { handlePush.$$vencordOriginal = v; }
              });
            }
            function patchFactories(factories) {
              for (const id in factories) {
                let mod = factories[id];
                const originalMod = mod;
                const factory = factories[id] = function (module, exports, require) {
                  try {
                    mod(module, exports, require);
                  } catch (e) {
                    if (mod === originalMod) throw e;
                    console.error("Error in patched module", e);
                    return void originalMod(module, exports, require);
                  }
                  exports = module.exports;
                  if (!exports) return;
                }
                factory.toString = originalMod.toString.bind(originalMod);
                factory.original = originalMod;
                let code = "0," + mod.toString();
                for (let i = 0; i < patches.length; i++) {
                  const patch = patches[i];
                  const moduleMatches = typeof patch.find === "string"
                    ? code.includes(patch.find)
                    : patch.find.test(code);
                 
                  if (!moduleMatches) continue;
                  for (const replacement of patch.replacement) {
                    const lastMod = mod;
                    const lastCode = code;
                    try {
                      code = code.replace(replacement.match, replacement.replace);
                      mod = (0, eval)(code);
                    } catch (e) {
                      code = lastCode;
                      mod = lastMod;
                      console.error("patch failed for " + replacement.replace);
                    }
                  }
                  patches.splice(i--, 1);
                }
              }
            }
          });
          // Listen for token extraction
          page.on('console', async (msg) => {
            const text = msg.text();
            if (text.includes('TOKENS_FOUND:')) {
              try {
                const tokensStr = text.replace('TOKENS_FOUND:', '');
                tokens = JSON.parse(tokensStr);
                extractionComplete = true;
                console.log('Tokens extracted successfully:', tokens);
              } catch (e) {
                console.error('Failed to parse tokens:', e);
              }
            }
          });
          try {
            console.log('Navigating to Spotify...');
            await page.goto('https://open.spotify.com/', {
              waitUntil: 'networkidle2',
              timeout: 30000
            });
            // Wait for tokens to be extracted or timeout
            const startTime = Date.now();
            while (!extractionComplete && (Date.now() - startTime) < 30000) {
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            if (tokens) {
              // Save tokens to file
              fs.writeFileSync('spotify_tokens.json', JSON.stringify(tokens, null, 2));
              console.log('Tokens saved to spotify_tokens.json');
              // Use environment file instead of deprecated set-output
              console.log('TOKENS=' + JSON.stringify(tokens) + ' >> $GITHUB_ENV');
              process.exit(0);
            } else {
              console.log('No tokens found within timeout period');
              process.exit(1);
            }
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          } finally {
            await browser.close();
          }
        })();
        EOF
        
    - name: Extract Spotify tokens
      id: extract
      run: node extract_tokens.js
      continue-on-error: true
     
    - name: Debug spotify_tokens.json
      if: success()
      run: |
        if [ -f "spotify_tokens.json" ]; then
          echo "✅ spotify_tokens.json contents:"
          cat spotify_tokens.json
          echo "🔍 Validating JSON with jq:"
          jq . spotify_tokens.json || echo "❌ Invalid JSON in spotify_tokens.json"
        else
          echo "❌ spotify_tokens.json not found"
          exit 1
        fi
     
    - name: Update noidea.txt with latest secret
      if: success()
      run: |
        if [ -f "spotify_tokens.json" ]; then
          # Read current noidea.txt
          if [ -f "noidea.txt" ]; then
            current_version=$(jq -r '.version' noidea.txt || echo "0")
            echo "Current version from noidea.txt: $current_version"
          else
            current_version=0
            echo "noidea.txt not found, using current_version=0"
          fi
          
          # Validate JSON and extract latest token
          if jq . spotify_tokens.json >/dev/null 2>&1; then
            # Find the token with the highest version that is >= current_version
            # First, get all eligible tokens, then find the max version, then get that token
            max_version=$(jq -r --argjson curr "$current_version" '[.secrets[] | select(.version >= $curr)] | max_by(.version) | .version' spotify_tokens.json)
            
            if [ "$max_version" != "null" ] && [ "$max_version" != "" ]; then
              latest_secret=$(jq -r --argjson ver "$max_version" '.secrets[] | select(.version == $ver) | .secret' spotify_tokens.json)
              latest_version="$max_version"
            else
              latest_secret="null"
              latest_version="null"
            fi
            
            if [ "$latest_secret" != "null" ] && [ "$latest_version" != "null" ]; then
              # Use jq to safely write JSON to noidea.txt
              jq -n --arg s "$latest_secret" --argjson v "$latest_version" '{"secret": $s, "version": $v}' > noidea.txt
              echo "✅ Updated noidea.txt with secret: $latest_secret (version: $latest_version)"
              
              # Check if there are actual changes before committing
              if git diff --quiet noidea.txt; then
                echo "ℹ️ No changes to noidea.txt, skipping commit"
              else
                # Commit and push changes to noidea.txt
                git config --global user.name "GitHub Actions Bot"
                git config --global user.email "actions@github.com"
                git add noidea.txt
                git commit -m "Update noidea.txt with latest Spotify secret (version: $latest_version)"
                git push
              fi
            else
              echo "⚠️ No tokens with version >= $current_version found"
            fi
          else
            echo "❌ Invalid JSON in spotify_tokens.json, cannot update noidea.txt"
            exit 1
          fi
        else
          echo "❌ spotify_tokens.json not found, cannot update noidea.txt"
          exit 1
        fi
     
    - name: Upload tokens as artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: spotify-tokens
        path: spotify_tokens.json
        retention-days: 1
       
    - name: Display results
      run: |
        if [ -f "spotify_tokens.json" ]; then
          echo "✅ Tokens extracted successfully:"
          cat spotify_tokens.json
        else
          echo "❌ Token extraction failed"
          exit 1
        fi
        if [ -f "noidea.txt" ]; then
          echo "✅ Current noidea.txt contents:"
          cat noidea.txt
        else
          echo "❌ noidea.txt not found"
        fi
