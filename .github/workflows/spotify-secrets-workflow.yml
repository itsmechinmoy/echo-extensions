name: Spotify Secret Workflow

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'  # Run every 6 hours

jobs:
  extract-secret:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install selenium webdriver-manager
          
      - name: Verify tampermonkey script exists
        run: |
          if [ ! -f "tampermonkey_script.js" ]; then
            echo "Error: tampermonkey_script.js not found in repository root"
            exit 1
          fi
          echo "✓ tampermonkey_script.js found"
          
      - name: Extract Spotify secrets
        run: |
          python3 << 'EOF'
          import time
          import os
          import json
          import tempfile
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from selenium.common.exceptions import TimeoutException, WebDriverException
          from webdriver_manager.chrome import ChromeDriverManager
          
          def setup_chrome_with_userscript():
              """Setup Chrome driver with userscript injection using CDP"""
              
              # Create temporary directory
              temp_dir = tempfile.mkdtemp(prefix='chrome_user_data_')
              extension_dir = tempfile.mkdtemp(prefix='chrome_extension_')
              
              # Read and clean the userscript
              with open('tampermonkey_script.js', 'r', encoding='utf-8') as f:
                  script_content = f.read()
              
              # Remove userscript headers
              lines = script_content.split('\n')
              script_lines = []
              in_header = False
              
              for line in lines:
                  if line.strip().startswith('// ==UserScript=='):
                      in_header = True
                      continue
                  elif line.strip().startswith('// ==/UserScript=='):
                      in_header = False
                      continue
                  elif not in_header:
                      script_lines.append(line)
              
              clean_script = '\n'.join(script_lines)
              
              # Create a more robust extension that injects into main world
              manifest = {
                  "manifest_version": 3,
                  "name": "Spotify Token Extractor",
                  "version": "1.0",
                  "content_scripts": [{
                      "matches": ["https://open.spotify.com/*"],
                      "js": ["content.js"],
                      "run_at": "document_start"
                  }],
                  "permissions": ["activeTab"],
                  "host_permissions": ["https://open.spotify.com/*"]
              }
              
              # Create content script that injects into main world
              content_script = f'''
              (function() {{
                  // Inject script into main world (page context) to bypass CSP
                  const script = document.createElement('script');
                  script.textContent = `
                      console.log('Spotify token extractor injected at document-start');
                      {clean_script}
                  `;
                  (document.head || document.documentElement).appendChild(script);
                  script.remove();
                  console.log('Script injected into main world');
              }})();
              '''
              
              # Write extension files
              with open(os.path.join(extension_dir, 'manifest.json'), 'w') as f:
                  json.dump(manifest, f, indent=2)
              
              with open(os.path.join(extension_dir, 'content.js'), 'w') as f:
                  f.write(content_script)
              
              print(f"✓ Created extension in {extension_dir}")
              
              # Setup Chrome options
              chrome_options = Options()
              chrome_options.add_argument('--headless=new')
              chrome_options.add_argument('--no-sandbox')
              chrome_options.add_argument('--disable-dev-shm-usage')
              chrome_options.add_argument('--disable-gpu')
              chrome_options.add_argument('--disable-web-security')
              chrome_options.add_argument('--disable-features=VizDisplayCompositor')
              chrome_options.add_argument('--disable-plugins')
              chrome_options.add_argument('--disable-images')
              chrome_options.add_argument('--disable-background-timer-throttling')
              chrome_options.add_argument('--disable-renderer-backgrounding')
              chrome_options.add_argument('--disable-backgrounding-occluded-windows')
              chrome_options.add_argument('--disable-ipc-flooding-protection')
              chrome_options.add_argument('--window-size=1920,1080')
              chrome_options.add_argument('--remote-debugging-port=9222')
              chrome_options.add_argument('--memory-pressure-off')
              chrome_options.add_argument('--max_old_space_size=4096')
              chrome_options.add_argument(f'--user-data-dir={temp_dir}')
              
              # Disable CSP and security features that might block script injection
              chrome_options.add_argument('--disable-web-security')
              chrome_options.add_argument('--disable-features=VizDisplayCompositor')
              chrome_options.add_argument('--allow-running-insecure-content')
              chrome_options.add_argument('--disable-blink-features=AutomationControlled')
              
              # Load the extension
              chrome_options.add_argument(f'--load-extension={extension_dir}')
              
              service = Service(ChromeDriverManager().install())
              driver = webdriver.Chrome(service=service, options=chrome_options)
              
              # Store the clean script for manual injection if needed
              driver._userscript = clean_script
              
              return driver, temp_dir, extension_dir
          
          def extract_tokens_with_extension(driver, max_attempts=3):
              """Extract tokens using the extension approach"""
              for attempt in range(max_attempts):
                  try:
                      print(f"Attempt {attempt + 1}/{max_attempts} to extract tokens...")
                      
                      # First, inject the script directly as a fallback
                      print("Pre-injecting script via execute_script...")
                      try:
                          driver.execute_script(f'''
                              console.log('Direct injection starting...');
                              {driver._userscript}
                              console.log('Direct injection completed');
                          ''')
                      except Exception as e:
                          print(f"Direct injection error: {e}")
                      
                      # Navigate to Spotify - extension will inject script at document-start
                      print("Navigating to Spotify...")
                      driver.get('https://open.spotify.com/')
                      
                      # Immediately inject script again after navigation for double coverage
                      print("Post-navigation script injection...")
                      try:
                          driver.execute_script(f'''
                              console.log('Post-nav injection starting...');
                              {driver._userscript}
                              console.log('Post-nav injection completed');
                          ''')
                      except Exception as e:
                          print(f"Post-nav injection error: {e}")
                      
                      # Wait for page to start loading
                      print("Waiting for page to load...")
                      time.sleep(8)  # Longer initial wait
                      
                      # Check what's actually happening on the page
                      try:
                          page_source_sample = driver.execute_script('''
                              return {
                                  title: document.title,
                                  hasWebpack: typeof window.webpackChunk_N_E !== 'undefined',
                                  hasTokens: typeof window.TOKENS !== 'undefined',
                                  webpackType: typeof window.webpackChunk_N_E,
                                  tokensType: typeof window.TOKENS,
                                  scripts: Array.from(document.scripts).length
                              }
                          ''')
                          print(f"Page state: {page_source_sample}")
                      except Exception as e:
                          print(f"Page state check error: {e}")
                      
                      # Wait for TOKENS to be available with longer timeout
                      print("Waiting for TOKENS to be available...")
                      
                      def tokens_available(driver):
                          try:
                              result = driver.execute_script('''
                                  console.log('Checking for TOKENS...', typeof window.TOKENS);
                                  if (window.TOKENS) {
                                      console.log('TOKENS found:', window.TOKENS);
                                      if (window.TOKENS.secrets && Array.isArray(window.TOKENS.secrets) && window.TOKENS.secrets.length > 1) {
                                          console.log('Secret found at index 1:', window.TOKENS.secrets[1]);
                                          return window.TOKENS.secrets[1];
                                      } else {
                                          console.log('No secrets array or insufficient length:', window.TOKENS.secrets);
                                      }
                                  } else {
                                      console.log('TOKENS not found');
                                  }
                                  return null;
                              ''')
                              if result:
                                  print(f"✓ TOKENS detected: {result}")
                                  return True
                              return False
                          except Exception as e:
                              print(f"Error checking tokens: {e}")
                              return False
                      
                      # Check periodically for tokens with more frequent checks
                      for i in range(24):  # Check for 120 seconds (24 * 5 seconds)
                          try:
                              if tokens_available(driver):
                                  break
                              print(f"Waiting... ({i+1}/24)")
                              
                              # Re-inject script every few attempts in case it failed
                              if i % 5 == 0 and i > 0:
                                  print("Re-injecting script...")
                                  try:
                                      driver.execute_script(f'''
                                          console.log('Re-injection starting...');
                                          {driver._userscript}
                                          console.log('Re-injection completed');
                                      ''')
                                  except:
                                      pass
                              
                              time.sleep(5)
                          except:
                              pass
                      else:
                          print("✗ Timeout waiting for TOKENS")
                          continue
                      
                      # Extract the secret
                      secret_data = driver.execute_script('''
                          try {
                              if (window.TOKENS && window.TOKENS.secrets && window.TOKENS.secrets[1]) {
                                  console.log('Extracting secret:', window.TOKENS.secrets[1]);
                                  return window.TOKENS.secrets[1];
                              }
                              return null;
                          } catch (e) {
                              console.error('Error extracting tokens:', e);
                              return null;
                          }
                      ''')
                      
                      if secret_data:
                          print(f"✓ Secret extracted: {json.dumps(secret_data)}")
                          return secret_data
                      else:
                          print("✗ No secret data found")
                          
                  except Exception as e:
                      print(f"✗ Error on attempt {attempt + 1}: {e}")
                      if attempt < max_attempts - 1:
                          print("Retrying...")
                          time.sleep(15)  # Longer delay between retries
              
              return None
          
          def main():
              driver = None
              temp_dir = None
              extension_dir = None
              
              try:
                  print("Setting up Chrome driver with extension...")
                  driver, temp_dir, extension_dir = setup_chrome_with_userscript()
                  
                  print("Starting token extraction...")
                  secret_data = extract_tokens_with_extension(driver)
                  
                  if secret_data:
                      # Format as array to match existing format
                      output_data = [secret_data]
                      
                      # Write to file
                      with open('noidea.txt', 'w', encoding='utf-8') as f:
                          json.dump(output_data, f, indent=2)
                      
                      print(f"✓ Secret saved to noidea.txt")
                      print(f"Secret: {json.dumps(output_data)}")
                      
                  else:
                      print("✗ Failed to extract secret after all attempts")
                      
                      # Debug: Check what's on the page
                      try:
                          page_title = driver.title
                          print(f"Page title: {page_title}")
                          
                          # Check for any errors in console
                          logs = driver.get_log('browser')
                          print("Browser console logs:")
                          for log in logs[-10:]:  # Last 10 logs
                              print(f"  {log['level']}: {log['message']}")
                              
                      except Exception as e:
                          print(f"Debug info error: {e}")
                      
                      exit(1)
                      
              except Exception as e:
                  print(f"✗ Fatal error: {e}")
                  exit(1)
                  
              finally:
                  if driver:
                      try:
                          driver.quit()
                          print("✓ Driver closed")
                      except:
                          pass
                  
                  # Clean up temp directories
                  for directory in [temp_dir, extension_dir]:
                      if directory and os.path.exists(directory):
                          try:
                              shutil.rmtree(directory, ignore_errors=True)
                              print(f"✓ Cleaned up {directory}")
                          except:
                              pass
          
          if __name__ == "__main__":
              main()
          EOF
          
      - name: Check if secret was extracted
        run: |
          if [ -f "noidea.txt" ]; then
            echo "✓ Secret file created"
            echo "Content:"
            cat noidea.txt
          else
            echo "✗ Secret file not found"
            exit 1
          fi
          
      - name: Commit and push changes
        run: |
          git config --local user.name 'github-actions[bot]'
          git config --local user.email 'github-actions[bot]@users.noreply.github.com'
          
          # Check if there are changes
          if git diff --quiet noidea.txt; then
            echo "No changes to commit"
          else
            git add noidea.txt
            git commit -m "Update Spotify secrets - $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            git push
            echo "✓ Changes committed and pushed"
          fi
